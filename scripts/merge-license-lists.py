#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
#
# Helper to merge multiple Yocto license manifests and their accompanying
# license directories into a single artefact.
#
# Inputs are the build TMPDIRs for the individual configurations. For each
# TMPDIR we pull in all `deploy/licenses/*/license.manifest` files, merge the
# package entries, and collect the recipe specific license files.

from __future__ import annotations

import argparse
import json
import shutil
import sys
from collections import OrderedDict, defaultdict
from pathlib import Path
from typing import Dict, Iterable, List, Tuple


KEY_FIELDS = ("PACKAGE NAME", "PACKAGE VERSION", "RECIPE NAME", "LICENSE")


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Merge Yocto license manifests from multiple build directories."
    )
    parser.add_argument(
        "--output-dir",
        required=True,
        help="Directory to place the merged licence artefacts into.",
    )
    parser.add_argument(
        "--tag",
        default="",
        help="Optional tag that is written into the combined licence manifest header.",
    )
    parser.add_argument(
        "--input",
        action="append",
        required=True,
        metavar="LABEL=TMPDIR",
        help="Build TMPDIR whose licenses should be merged. May be given multiple times.",
    )
    return parser.parse_args()


def normalise_builds(raw_inputs: Iterable[str]) -> List[Dict[str, Path]]:
    builds: List[Dict[str, Path]] = []
    name_counts: Dict[str, int] = defaultdict(int)

    for entry in raw_inputs:
        if "=" not in entry:
            raise ValueError(f"Invalid --input entry '{entry}'; expected LABEL=TMPDIR.")

        name, path = entry.split("=", 1)
        name = name.strip()
        tmpdir = Path(path.strip()).expanduser().resolve()

        if not name:
            raise ValueError(f"Invalid --input entry '{entry}'; LABEL must not be empty.")

        name_counts[name] += 1
        count = name_counts[name]
        label = name if count == 1 else f"{name}_{count}"

        builds.append(
            {
                "name": name,
                "label": label,
                "tmpdir": tmpdir,
                "licenses": tmpdir / "deploy" / "licenses",
            }
        )

    return builds


def parse_manifest(path: Path) -> List[OrderedDict]:
    blocks: List[OrderedDict] = []
    current: List[Tuple[str, str]] = []

    with path.open("r", encoding="utf-8", errors="replace") as handle:
        for raw_line in handle:
            line = raw_line.rstrip("\n")
            if not line.strip():
                if current:
                    blocks.append(OrderedDict(current))
                    current = []
                continue

            if ":" not in line:
                # Ignore unexpected lines without key/value separator.
                continue

            key, value = line.split(":", 1)
            current.append((key.strip(), value.strip()))

    if current:
        blocks.append(OrderedDict(current))

    return blocks


def merge_entries(builds: List[Dict[str, Path]]) -> Tuple[OrderedDict, List[Tuple[Dict, Path, Path]]]:
    merged: OrderedDict = OrderedDict()
    manifest_sources: List[Tuple[Dict, Path, Path]] = []

    for build in builds:
        lic_dir = build["licenses"]
        if not lic_dir.is_dir():
            build["missing"] = True
            continue

        for manifest_path in sorted(lic_dir.glob("*/*/license.manifest")):
            rel_dir = manifest_path.parent.relative_to(lic_dir)
            blocks = parse_manifest(manifest_path)

            for block in blocks:
                key = tuple(block.get(field, "") for field in KEY_FIELDS)
                entry = merged.setdefault(
                    key,
                    {
                        "block": OrderedDict(block),
                        "machines": OrderedDict(),
                    },
                )

                # If we encounter additional metadata for an existing entry, keep it.
                existing_block: OrderedDict = entry["block"]
                for field, value in block.items():
                    if field not in existing_block:
                        existing_block[field] = value

                machine = build["name"]
                label = build["label"]
                context = f"{label}:{rel_dir}"

                entry["machines"].setdefault(machine, set()).add(context)

            manifest_sources.append((build, manifest_path, rel_dir))

    return merged, manifest_sources


def write_manifest(output: Path, tag: str, builds: List[Dict[str, Path]], merged: OrderedDict) -> None:
    with output.open("w", encoding="utf-8") as handle:
        handle.write("# Combined license manifest generated by merge-license-lists.py\n")
        if tag:
            handle.write(f"# Tag: {tag}\n")
        handle.write("# Builds included in this manifest:\n")
        for build in builds:
            missing_marker = " (missing licences!)" if build.get("missing") else ""
            handle.write(
                f"#   {build['label']} (machine: {build['name']}): {build['tmpdir']}{missing_marker}\n"
            )
        handle.write("\n")

        for entry in merged.values():
            block: OrderedDict = entry["block"]
            for field, value in block.items():
                handle.write(f"{field}: {value}\n")

            machines_line = ", ".join(entry["machines"].keys())
            handle.write(f"EM_LICENSE_MACHINES: {machines_line}\n")

            for machine, contexts in entry["machines"].items():
                formatted = ", ".join(sorted(contexts))
                handle.write(f"EM_LICENSE_SOURCES[{machine}]: {formatted}\n")

            handle.write("\n")


def copy_manifest_sources(dest: Path, manifest_sources: List[Tuple[Dict, Path, Path]]) -> None:
    for build, manifest_path, rel_dir in manifest_sources:
        dest_dir = dest / "manifests" / build["label"] / rel_dir
        dest_dir.mkdir(parents=True, exist_ok=True)
        shutil.copy2(manifest_path, dest_dir / "license.manifest")


def copy_license_directories(dest: Path, builds: List[Dict[str, Path]]) -> None:
    dest_basename = dest.name

    for build in builds:
        lic_dir = build["licenses"]
        if not lic_dir.is_dir():
            continue

        target_root = dest / "licenses" / build["label"]
        if target_root.exists():
            shutil.rmtree(target_root)
        target_root.mkdir(parents=True, exist_ok=True)

        for entry in lic_dir.iterdir():
            name = entry.name
            if name == dest_basename:
                continue

            target_path = target_root / name

            if entry.is_dir():
                shutil.copytree(entry, target_path, symlinks=True)
            elif entry.is_file():
                shutil.copy2(entry, target_path)


def write_metadata(dest: Path, builds: List[Dict[str, Path]]) -> None:
    metadata = [
        {
            "machine": build["name"],
            "label": build["label"],
            "tmpdir": str(build["tmpdir"]),
            "licenses_dir": str(build["licenses"]),
            "missing": bool(build.get("missing")),
        }
        for build in builds
    ]

    with (dest / "builds.json").open("w", encoding="utf-8") as handle:
        json.dump(metadata, handle, indent=2)
        handle.write("\n")


def main() -> int:
    args = parse_arguments()

    try:
        builds = normalise_builds(args.input)
    except ValueError as err:
        print(f"error: {err}", file=sys.stderr)
        return 1

    output_dir = Path(args.output_dir).resolve()
    if output_dir.exists():
        shutil.rmtree(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    merged, manifest_sources = merge_entries(builds)
    write_manifest(output_dir / "license.manifest", args.tag, builds, merged)
    copy_manifest_sources(output_dir, manifest_sources)
    copy_license_directories(output_dir, builds)
    write_metadata(output_dir, builds)

    return 0


if __name__ == "__main__":
    sys.exit(main())
